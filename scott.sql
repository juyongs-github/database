-- SELECT(조회)

-- emp(사원) 테이블
-- empno(사번) : number(4,0) => 숫자, 4자리, 소수점 아래 자릿수는 0
-- ename(이름) : varchar2(10) => 문자
-- job(직무) : varchar2(9)
-- mgr(매니저-사수 사원번호)
-- hiredate(입사일)
-- sal(급여) : number(7,2)
-- comm(수당)
-- deptno(부서번호)

-- dept(부서) 테이블
-- deptno(부서번호)
-- dname(부서명)
-- loc(부서위치)

-- 조회 기본 구문
-- SELECT 열이름... FROM 테이블명;
-- SELECT 열이름... FROM 테이블명 WHERE 조건 나열;

-- 1) 전체 사원 조회 시 사원 모든 정보 추출
SELECT *
FROM EMP;

-- 2) 전체 사원 조회 시 사원 이름만 추출
SELECT ename
FROM EMP;

-- 3) 전체 사원 조회 시 사번, 사원명, 부서번호만 추출
SELECT empno, ename, deptno
FROM EMP;

-- 4) 전체 사원 조회 시 부서번호만 추출
SELECT deptno 
FROM EMP;

-- 5) 전체 사원 조회 시 부서번호만 추출(중복 데이터 제거)
SELECT DISTINCT deptno
FROM EMP;

-- 6) 별칭(alias)
SELECT ename 사원명
FROM EMP; -- O

SELECT ename 사원 이름
FROM EMP; -- X

SELECT ename "사원명"
FROM EMP; -- O

SELECT ename AS "사원 이름"
FROM EMP; -- O

-- 7) 연봉 구하기 (sal * 12 + comm)
SELECT empno, sal * 12 + comm AS "연봉"
FROM EMP;

-- 8) 오름차순, 내림차순 정렬 : ORDER BY 정렬기준 열이름... ASC(오름차순) OR DESC(내림차순)
-- ASC는 생략 가능
SELECT *
FROM EMP
ORDER BY sal ASC;

SELECT *
FROM EMP
ORDER BY sal DESC;

SELECT *
FROM EMP
ORDER BY sal DESC, ename ASC;

-- [실습]
-- empno : employee_no,
-- ename : employee_name,
-- mgr : manager,
-- sal : salary,
-- comm : commission,
-- deptno : department_no
-- 별칭 지정, 부서번호를 기준으로 내림차순 정렬, 단 부서번호가 같다면 이름 오름차순
SELECT
	empno AS employee_no,
	ename AS employee_name,
	mgr AS manager,
	sal AS salary,
	comm AS commission,
	deptno AS department_no
FROM EMP
ORDER BY department_no DESC, employee_name;

-- 부서번호가 30번인 사원정보 조회
SELECT *
FROM EMP
WHERE deptno = 30;

-- 사번이 7698인 사원정보 조회
SELECT *
FROM EMP
WHERE empno = 7698;

-- 부서번호가 30번 이고 사원직책이 salesman인 사원정보 조회
SELECT *
FROM EMP
WHERE deptno = 30
AND job = 'SALESMAN';

-- 부서번호가 30번 이거나 사원직책이 analyst인 사원정보 조회
SELECT *
FROM EMP
WHERE deptno = 30
OR job = 'ANALYST'

-- 연산자
-- =, >, <, >=, <=, AND, OR, !=, <>, ^=
-- IN, BETWEEN A AND B (A 이상 B 이하)
-- LIKE

-- 연봉이 36000인 사원 조회
SELECT *
FROM EMP
WHERE sal * 12 = 36000;

-- 급여가 3000 초과인 사원 조회
SELECT *
FROM EMP
WHERE sal > 3000;

-- 이름이 'F' 이후의 문자로 시작하는 사원 조회
SELECT *
FROM EMP
WHERE ename >= 'F';

-- 직무가 manager, salesman, clerk인 사원 조회
SELECT *
FROM EMP
WHERE JOB = 'MANAGER' OR JOB = 'SALESMAN' OR JOB = 'CLERK';

SELECT *
FROM EMP
WHERE job IN ('MANAGER', 'SALESMAN', 'CLERK');

-- 직무가 manager, salesman, clerk이 아닌 사원 조회
SELECT *
FROM EMP
WHERE job NOT IN ('MANAGER', 'SALESMAN', 'CLERK');

-- sal이 3000이 아닌 사원 조회
SELECT *
FROM EMP
WHERE sal != 3000;

SELECT *
FROM EMP
WHERE sal <> 3000;

SELECT *
FROM EMP
WHERE sal ^= 3000;

-- 부서번호가 10, 20번인 사원 조회
SELECT *
FROM EMP
WHERE deptno = 10 OR deptno = 20;

SELECT *
FROM EMP
WHERE deptno IN (10, 20);

-- 급여가 2000 이상 3000 이하인 사원 조회
SELECT *
FROM EMP
WHERE sal >= 2000 AND sal <= 3000;

SELECT *
FROM EMP
WHERE sal BETWEEN 2000 AND 3000;

-- 급여가 2000 이상 3000 이하가 아닌 사원 조회
SELECT *
FROM EMP
WHERE sal NOT BETWEEN 2000 AND 3000;

-- LIKE + 와일드 카드(%, _)
-- % : 길이와 상관 없이(문자 없는 경우도 포함) 모든 문자 데이터를 의미
-- _ : 한개의 문자 데이터를 의미
-- 사원명이 S로 시작하는 사원들의 정보 조회
SELECT *
FROM EMP
WHERE ename LIKE 'S%';

-- 사원명의 두번째 글자가 L인 사원들의 정보 조회
SELECT *
FROM EMP
WHERE ename LIKE '_L%';

-- 사원이름에 AM이 포함된 사원들의 정보 조회
SELECT *
FROM EMP
WHERE ename LIKE '%AM%';

-- 사원이름에 AM이 포합되지 않은 사원들의 정보 조회
SELECT *
FROM EMP
WHERE ename NOT LIKE '%AM%'

-- NULL 값 비교
SELECT *
FROM EMP WHERE comm IS NULL;

SELECT *
FROM EMP WHERE comm IS NOT NULL;



-- 집합 연산자
-- 합집합(UNION, UNION ALL), 교집합(INTERSECT), 차집합(MINUS)
-- UNION: 중복 제거, UNION ALL: 중복 제거 X
-- DEPTNO = 10, UNION DEPTNO = 20
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE DEPTNO = 10
UNION
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE DEPTNO = 20;

SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE DEPTNO = 10
UNION ALL
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE DEPTNO = 10;

-- MINUS
SELECT EMPNO, ENAME, SAL
FROM EMP
MINUS
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE DEPTNO = 10;

-- [실습]
-- 1. 사원 이름이 S로 끝나는 사원 데이터 조회
SELECT *
FROM EMP
WHERE ENAME LIKE '%S';

-- 2. 30번 부서에 근무하고 있는 사원 중에 JOB이 SALESMAN인 사원의 사원번호, 이름, 직책, 급여, 부서번호 조회
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 30
AND JOB = 'SALESMAN';

-- 3. 20번, 30번 부서에 근무하고 있는 사원 중 급여가 2000 초과인 사원을 다음 두 방식의 SELECT 문을 사용하여
-- 사원번호, 이름, 직책, 급여, 부서 번호를 출력
-- 1) 집합 연산자를 사용하는 방식
-- 2) 집합 연산자를 사용하지 않는 방식
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 20
AND SAL > 2000
UNION
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 30
AND SAL > 2000;

SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP
WHERE SAL > 2000
MINUS
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 10;

SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP
WHERE DEPTNO IN (20, 30)
AND SAL > 2000;

-- 4. NOT BETWEEN A AND B 연산자를 사용하지 않고 급여가 2000 이상 3000 이하 범위 이외의 값을 가진 데이터 조회
SELECT *
FROM EMP
WHERE SAL < 2000 OR SAL > 3000;

-- 5. 사원 이름에 E가 포함된 30번 부서의 사원 중 급여가 1000 ~ 2000 사이가 아닌 사원명, 사번, 급여, 부서번호 조회
SELECT ENAME, EMPNO, SAL, DEPTNO 
FROM EMP
WHERE ENAME LIKE '%E%'
AND DEPTNO = 30
AND SAL NOT BETWEEN 1000 AND 2000;

-- 6. 추가 수당이 없고 상급자가 있고 직책이 MANAGER, CLERK인 사원 중에서 사원이름의 두번째 글자가 L이 아닌 사원의 정보를 조회
SELECT *
FROM EMP
WHERE COMM IS NULL
AND MGR IS NOT NULL
AND JOB IN ('MANAGER', 'CLERK')
AND ENAME NOT LIKE '_L%';



-- 함수
-- 1. 문자 함수
-- UPPER(문자열) : 대문자 변환
-- LOWER(문자열) : 소문자 변환
-- INITCAP(문자열) : 첫글자는 대문자, 나머지 문자는 소문자
-- LENGTH(문자열) : 문자열 길이
-- LENGTHB(문자열) : 문자열의 바이트 길이
-- SUBSTR(문자열, 시작위치, 추출길이) : 문자열 부분추출
-- INSTR(대상문자열, 위치를 찾으려는 문자, 시작위치, 찾으려는 문자가 몇 번째인지) : 문자열에서 특정 문자 위치 찾기
-- REPLACE(문자열, 찾는문자, 바꿀문자) : 문자열 바꾸기
-- CONCAT(문자열1, 문자열2) : 문자열 합치기
-- TRIM(삭제옵션(선택), 삭제할문자 FROM 원본문자열(선택))
-- 1) 삭제옵션 : LEADING OR TRAILING OR BOTH
-- LTRIM(원본문자열, 삭제할문자열)
-- RTRIM(원본문자열, 삭제할문자열)
SELECT ENAME, UPPER(ENAME), LOWER(ENAME), INITCAP(ENAME)
FROM EMP;

SELECT ENAME, LENGTH(ENAME), LENGTHB(ENAME)
FROM EMP;

-- DAUL(SYS 소유의 테이블, 더미 테이블)
-- 임시연산이나 함수의 결과값 확인 용도
SELECT LENGTH('한글'), LENGTHB('한글')
FROM DAUL;

-- 사원명 길이가 5이상인 사원 조회
SELECT *
FROM EMP
WHERE LENGTH(ENAME) >= 5;

-- 직책명이 6자 이상인 사원 조회
SELECT *
FROM EMP
WHERE LENGTH(JOB) >= 6;

-- EMP 테이블에서 사원명을 세번째 글자부터 끝까지 출력
SELECT SUBSTR(ENAME, 3)
FROM EMP;

SELECT 
	INSTR('HELLO, ORACLE!', 'L') AS 첫번째,
	INSTR('HELLO, ORACLE!', 'L', 5) AS 두번째,
	INSTR('HELLO, ORACLE!', 'L', 2, 2) AS 세번째
FROM DUAL;

-- 사원명에 문자 S가 포함된 사원 조회
-- 1) LIKE 2) INSTR()
SELECT *
FROM EMP
WHERE INSTR(ENAME, 'S') > 0;

-- 010-4526-7858 => 010 4526 7858 OR 01045267858
SELECT 
	'010-4526-7858' AS BEFORE, 
	REPLACE('010-4526-7858', '-', ' ') AS REPLACE1, 
	REPLACE('010-4526-7858', '-') AS REPLACE2
FROM DUAL;

-- EMPNO, ENAME 합치기
-- CONCAT() OR ||
SELECT CONCAT(EMPNO, ENAME), CONCAT(EMPNO, CONCAT(':', ENAME))
FROM EMP;

SELECT EMPNO || ENAME, EMPNO || ':' || ENAME
FROM EMP;

-- TRIM()
SELECT 
	'[' || TRIM(' __Oracle__ ') || ']' AS TRIM,
	'[' || TRIM(LEADING FROM ' __Oracle__ ') || ']' AS TRIM_LEADING, -- LTRIM()
	'[' || TRIM(TRAILING FROM ' __Oracle__ ') || ']' AS TRIM_TRAILING, -- RTRIM()
	'[' || TRIM(BOTH FROM ' __Oracle__ ') || ']' AS TRIM_BOTH
FROM DUAL;

SELECT 
	'[' || TRIM(' _Oracle_ ') || ']' AS TRIM,
	'[' || LTRIM(' _Oracle_ ') || ']' AS LTRIM,
	'[' || LTRIM('<_Oracle_>', '_<') || ']' AS LTRIM2,
	'[' || RTRIM(' _Oracle_ ') || ']' AS RTRIM,
	'[' || RTRIM('<_Oracle_>', '>_') || ']' AS RTRIM2,
	'[' || TRIM(BOTH FROM ' __Oracle__ ') || ']' AS TRIM_BOTH
FROM DUAL;

-- 2. 숫자함수
-- ROUND(숫자, 반올림위치) : 반올림
-- TRUNC(숫자, 버림위치) : 버림
-- CEIL(숫자) : 지정된 숫자보다 큰 정수 중 가장 작은 정수 반환
-- FLOOR(숫자) : 지정된 숫자보다 작은 정수 중 가장 큰 정수 반환
-- MOD(숫자, 반올림위치) : 지정된 숫자를 나눈 나머지 반환
SELECT
	ROUND(1234.5678) AS ROUND,
	ROUND(1234.5678, 0) AS ROUND0,
	ROUND(1234.5678, 1) AS ROUND1,
	ROUND(1234.5678, 2) AS ROUND2,
	ROUND(1234.5678, -1) AS ROUND_MINUS1,
	ROUND(1234.5678, -2) AS ROUND_MINUS2
FROM DUAL;

SELECT
	TRUNC(1234.5678) AS TRUNC,
	TRUNC(1234.5678, 0) AS TRUNC0,
	TRUNC(1234.5678, 1) AS TRUNC1,
	TRUNC(1234.5678, 2) AS TRUNC2,
	TRUNC(1234.5678, -1) AS TRUNC_MINUS1,
	TRUNC(1234.5678, -2) AS TRUNC_MINUS2
FROM DUAL;

SELECT CEIL(3.14), FLOOR(3.14), CEIL(-3.14), FLOOR(-3.14)
FROM DUAL;

SELECT MOD(15, 6), MOD(10, 2), MOD(11, 2)
FROM DUAL;

-- 3. 날짜함수
-- 날짜 데이터 + 숫자 : 이후 날짜 반환
-- 날짜 데이터 - 숫자 : 이전 날짜 반환
-- 날짜 데이터 - 날짜 데이터 : 두 날짜 데이터 간의 일수 차이 반환
-- 날짜 데이터 + 날짜 데이터 : 연산 불가
-- ADD_MONTHS(날짜데이터, 더할개월수)
-- MONTHS_BETWEEN(날짜데이터1, 날짜데이터2)
-- NEXT_DAY(날짜데이터, 요일문자)
-- LAST_DAY(날짜데이터)
-- SYSDATE : ORACLE에서 시스템 날짜 출력 (CURRENT_DATE, CURRENT_TIMESTAMP)
SELECT SYSDATE, SYSDATE + 1, SYSDATE - 1, CURRENT_DATE, CURRENT_TIMESTAMP
FROM DUAL;

SELECT ADD_MONTHS(SYSDATE, 3)
FROM DUAL;

-- EMP 테이블에서 입사 50주년이 되는 날짜 구하기
SELECT HIREDATE, ADD_MONTHS(HIREDATE, 12 * 50)
FROM EMP;

-- 입사한지 40년이 넘은 사원 조회
SELECT *
FROM EMP
WHERE ADD_MONTHS(HIREDATE, 12 * 40) < SYSDATE;

SELECT 
	EMPNO, 
	HIREDATE, 
	SYSDATE, 
	MONTHS_BETWEEN(HIREDATE, SYSDATE) AS MONTH1,
	MONTHS_BETWEEN(SYSDATE, HIREDATE) AS MONTH2,
	TRUNC(MONTHS_BETWEEN(SYSDATE, HIREDATE)) AS MONTH3
FROM EMP;

SELECT SYSDATE, LAST_DAY(SYSDATE), NEXT_DAY(SYSDATE, '월요일')
FROM DUAL;

-- 4. 형변환 함수
-- TO_CHAR() : 날짜, 숫자 데이터를 문자로 변환 (★유용하게 쓰임)
-- TO_NUMBER() : 문자 데이터를 숫자로 변환
-- TO_DATE() : 문자 데이터를 날짜 데이터로 변환
SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY-MM-DD')
FROM DUAL;

SELECT 
	SYSDATE, 
	TO_CHAR(SYSDATE, 'MM'), 
	TO_CHAR(SYSDATE, 'MON'), 
	TO_CHAR(SYSDATE, 'MONTH'), 
	TO_CHAR(SYSDATE, 'DD'), 
	TO_CHAR(SYSDATE, 'DAY')
FROM DUAL;

SELECT 
	SYSDATE, 
	TO_CHAR(SYSDATE, 'HH24:MI:SS'), 
	TO_CHAR(SYSDATE, 'HH12:MI:SS AM'), 
	TO_CHAR(SYSDATE, 'HH:MI:SS P.M.')
FROM DUAL;

SELECT EMPNO, ENAME, EMPNO + '500'
FROM EMP
WHERE ENAME = 'SMITH';

SELECT EMPNO, ENAME, EMPNO + 'ABCD'
FROM EMP
WHERE ENAME = 'SMITH';

SELECT SAL, TO_CHAR(SAL, '$999,999'), TO_CHAR(SAL, 'L999,999')
FROM EMP;

SELECT TO_NUMBER('1,300', '999,999') - TO_NUMBER('1,500', '999,999'), '1300' + 1500
FROM DUAL;

SELECT TO_DATE('20251027', 'YYYY-MM-DD'), TO_DATE('20251027', 'YYYY/MM/DD')
FROM DUAL;

SELECT TO_DATE('2025-10-27') - TO_DATE('2025-09-23')
FROM DUAL;

-- NULL 처리 함수
-- 1. NVL(컬럼명, 반환할 데이터) : NULL일 경우 반환할 데이터 반환
-- 2. NVL2(컬럼명, NULL이 아닐 때 반환할 데이터, NULL이 아닐 경우 반환할 데이터)
-- NULL + NULL = NULL
-- 숫자 + NULL = NULL
SELECT EMPNO, ENAME, SAL, COMM, COMM + SAL
FROM EMP;

SELECT EMPNO, ENAME, SAL, COMM, NVL(COMM, 0) + SAL
FROM EMP;

SELECT EMPNO, ENAME, SAL, COMM, NVL2(COMM, 'O', 'X'), NVL2(COMM, SAL * 12 + COMM, SAL * 12)
FROM EMP;

-- DECODE(), CASE(): 상황에 따라 다른 데이터를 반환
-- 직책이 MANAGER인 사원은 급여의 10%, SALESMAN인 사원은 급여의 5%, ANALYST인 사원은 그대로, 나머지 3%만큼 인상된 급여 구하기
SELECT 
	EMPNO, 
	ENAME, 
	JOB, 
	SAL, 
	DECODE(JOB, 'MANAGER', SAL * 1.1, 'SALESMAN', SAL * 1.05, 'ANALYST', SAL, SAL * 1.03) AS 급여
FROM EMP;

SELECT 
	EMPNO, 
	ENAME, 
	JOB, 
	SAL, 
	CASE JOB
		WHEN 'MANAGER' THEN SAL * 1.1 
		WHEN 'SALESMAN' THEN SAL * 1.05
		WHEN 'ANALYST' THEN SAL
		ELSE SAL * 1.03 
	END AS 급여
FROM EMP;

-- COMM이 NULL인 경우에는 해당없음, 0인 경우에는 수당없음, 0보다 큰 경우에는 수당 800
SELECT
	EMPNO,
	ENAME,
	COMM,
	CASE
		WHEN COMM IS NULL THEN '해당없음'
		WHEN COMM = 0 THEN '수당없음'
		WHEN COMM > 0 THEN '수당 : ' || COMM
	END AS COMM_TEXT
FROM EMP;

-- EMP 테이블에서 사원의 월 평균 근무일수는 21.5일
-- 하루 근무시간을 8시간으로 봤을 때 사원의 하루급여(DAY_PAY), 시급(TIME_PAY)를 계산하여 결과를 출력
-- 하루 급여는 소수 셋째 자리에서 버리고, 시급은 소수 둘째 자리에서 반올림
SELECT EMPNO, ENAME, SAL, TRUNC(SAL / 21.5, 2) AS DAY_PAY, ROUND(SAL / 21.5 / 8, 1) AS TIME_PAY
FROM EMP;

-- EMP 테이블에서 사원은 입사일을 기준으로 3개월이 지난 후 첫 월요일에 정직원이 된다. 사원이 정직원이 되는 날짜(R_JOB)을
-- YYYY-MM-DD 형식으로 출력. 단, 추가수당이 없는 사원의 추가 수당은 N/A로 출력
-- EMPNO, ENAME, HIREDATE, R_JOB, COMM 출력
SELECT
	EMPNO,
	ENAME,
	HIREDATE,
	TO_CHAR(NEXT_DAY(ADD_MONTHS(HIREDATE, 3), '월요일'), 'YYYY-MM-DD') AS R_JOB,
	NVL(TO_CHAR(COMM), 'N/A') AS COMM
FROM EMP;

-- EMP 테이블의 모든 사원을 대상으로 직속 상관의 사원번호(MGR)를 아래의 조건을 기준으로 변환해서 CHG_MGR 열에 출력
-- 조건
-- 직속 상관의 번호가 없는 경우 0000
-- 직속 상관의 사원번호 앞 두자리가 75일 때 5555
-- 직속 상관의 사원번호 앞 두자리가 76일 때 6666
-- 직속 상관의 사원본호 앞 두자리가 77일 때 7777
-- 직속 상관의 사원번호 앞 두자리가 78일 때 8888
-- 그 외 직속상관 사원 번호일 때 본래 직속상관의 사원번호 그대로 출력
SELECT
	EMPNO,
	ENAME,
	HIREDATE,
	MGR,
	CASE
		WHEN TO_CHAR(MGR) IS NULL THEN '0000'
		WHEN SUBSTR(TO_CHAR(MGR), 0, 2) = '75' THEN '5555'
		WHEN SUBSTR(TO_CHAR(MGR), 0, 2) = '76' THEN '6666'
		WHEN SUBSTR(TO_CHAR(MGR), 0, 2) = '77' THEN '7777'
		WHEN SUBSTR(TO_CHAR(MGR), 0, 2) = '78' THEN '8888'
	ELSE TO_CHAR(MGR) END AS CHG_MGR
FROM EMP;

-- 다중행 함수
-- SUM(), AVG(), COUNT(), MAX(), MIN()
SELECT SUM(SAL), AVG(SAL), MAX(SAL), MIN(SAL), COUNT(SAL)
FROM EMP;

SELECT SUM(DISTINCT SAL), AVG(DISTINCT SAL), MAX(DISTINCT SAL), MIN(DISTINCT SAL), COUNT(DISTINCT SAL)
FROM EMP;

-- 10번 부서의 급여 총계, 평균 구하기
SELECT SUM(SAL), AVG(SAL)
FROM EMP
WHERE DEPTNO = 10;

-- 20번 부서의 제일 오래된 입사일 구하기
SELECT MIN(HIREDATE)
FROM EMP
WHERE DEPTNO = 20;

-- 20번 부서의 제일 최신 입사일 구하기
SELECT MAX(HIREDATE)
FROM EMP
WHERE DEPTNO = 20;

-- GROUP BY : 결과값을 원하는 열로 묶어 출력
-- 부서별 급여평균 조회
-- 다중행 함수 옆에 올 수 있는 컬럼은 GROUP BY에 사용한 컬럼만 가능
SELECT DEPTNO, AVG(SAL)
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

-- 부서별, 직무별 급여 평균 조회
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

-- 부서별 추가수당 평균 조회
SELECT DEPTNO, AVG(NVL(COMM, 0))
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

-- 부서별, 직무별 급여 평균 조회(단, 평균이 2000 이상 그룹 조회)
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB;

-- EMP 테이블을 이용하여 부서번호, 평균급여(AVG_SAL), 최고급여(MAX_SAL), 최저급여(MIN_SAL), 사원수(CNT) 조회
-- 단, 평균급여 출력 시 소수점을 제외하고 각 부서번호별로 출력
SELECT DEPTNO, TRUNC(AVG(SAL)) AS AVG_SAL, MAX(SAL) AS MAX_SAL, MIN(SAL) AS MIN_SAL, COUNT(*) AS CNT
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

-- 같은 직책에 종사하는 사원이 3명 이상인 직책과 인원수 출력
SELECT JOB AS 직책, COUNT(*) AS 인원수
FROM EMP
GROUP BY JOB
HAVING COUNT(*) >= 3;

-- 사원들의 입사연도를 기준으로 부서별로 몇 명이 입사했는지 출력
SELECT TO_CHAR(HIREDATE, 'YYYY') AS 입사년도, DEPTNO AS 부서번호, COUNT(*) AS 인원수
FROM EMP
GROUP BY TO_CHAR(HIREDATE, 'YYYY'), DEPTNO
ORDER BY TO_CHAR(HIREDATE, 'YYYY'), DEPTNO;

-- JOIN : 여러 테이블을 하나의 테이블처럼 사용
-- 1. 내부 JOIN(INNER JOIN)
-- 2. 외부 JOIN(OUTER JOIN)
--     1) LEFT OUTER JOIN
--     2) RIGHT OUTER JOIN
--     3) FULL OUTER JOIN : LEFT OUTER JOIN +(UNION) RIGHT OUTER JOIN (구문은 따로 없음)

-- 사원정보 + 부서정보 조회
-- 내부조인 + 등가조인
SELECT *
FROM EMP E
JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND E.SAL >= 2000;

-- 비등가 조인 + 내부 조인
SELECT *
FROM EMP E
JOIN SALGRADE S
ON E.SAL BETWEEN S.LOSAL AND S.HISAL;

-- 셀프 조인
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.ENAME AS 매니저명
FROM EMP E1
JOIN EMP E2
ON E1.MGR = E2.EMPNO;

-- 외부 조인
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.ENAME AS 매니저명
FROM EMP E1
LEFT JOIN EMP E2
ON E1.MGR = E2.EMPNO;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.ENAME AS 매니저명
FROM EMP E1
RIGHT JOIN EMP E2
ON E1.MGR = E2.EMPNO;

-- + 부서명 조회
SELECT E.DEPTNO, D.DNAME, FLOOR(AVG(SAL)) AS AVG_SAL, MAX(SAL) AS MAX_SAL, MIN(SAL) AS MIN_SAL, COUNT(*) AS CNT
FROM EMP E
JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
GROUP BY E.DEPTNO, D.DNAME
ORDER BY E.DEPTNO;

-- TABLE 3개 연동
-- 부서번호, 부서명, 사원번호, 사원명, 매니저번호, 급여, 급여등급
-- 부서명 : DEPT
-- 사번, 사원명, 매니저번호, 급여, 부서번호 : EMP
-- 급여등급 : SALGRADE
SELECT E.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.MGR, E.SAL, S.GRADE
FROM EMP E
JOIN DEPT D

ON E.DEPTNO = D.DEPTNO
JOIN SALGRADE S
ON E.SAL BETWEEN S.LOSAL AND S.HISAL;

SELECT *
FROM EMP E, DEPT D, SALGRADE S
WHERE E.DEPTNO = D.DEPTNO
AND E.SAL BETWEEN S.LOSAL AND S.HISAL;

-- 서브쿼리 : 메인쿼리 외에 SELECT 구문이 여러개 존재
-- 1) 단일행 서브쿼리 : 서브쿼리 실행 결과가 행 하나
-- → 연산자 종류 : >, <, >=, <=, <>, !=, ^=, =
-- 2) 다중행 서브쿼리 : 서브쿼리 실행 결과가 행 여러개
-- → 연산자 종류 : IN, ANY(=SOME), ALL, EXIST
-- - IN : 서브쿼리 결과 중 하나라도 일치한 데이터가 있다면 TRUE 반환
-- - ANY, SOME : 서브쿼리 결과가 하나 이상이면 TRUE
-- - ALL : 
-- JONES의 급여보다 높은 급여를 받는 사원 데이터 조회
SELECT *
FROM EMP
WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'JONES');

-- WARD 사원보다 빨리 입사한 사원 조회
SELECT *
FROM EMP
WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME = 'WARD');

-- 20번 부서에 속한 사원 중 전체 사원의 평균급여보다 높은 급여를 받는 사원 조회
-- 부서 정보 추가로 조회
SELECT E.EMPNO, E.ENAME, E.JOB, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E
JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE E.DEPTNO = 20
AND E.SAL > (SELECT AVG(SAL) FROM EMP);

SELECT *
FROM EMP
WHERE SAL IN (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

SELECT *
FROM EMP
WHERE SAL = ANY (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

-- 30번 부서의 최대 급여보다 적은 급여를 받는 사원 조회
SELECT *
FROM EMP
WHERE SAL < ANY (SELECT SAL FROM EMP WHERE DEPTNO = 30);

-- 30번 부서의 최소 급여보다 많은 급여를 받는 사원 조회
SELECT *
FROM EMP
WHERE SAL > ANY (SELECT SAL FROM EMP WHERE DEPTNO = 30);

-- 30번 부서의 최소 급여보다 더 적은 급여를 받는 사원 조회
SELECT *
FROM EMP
WHERE SAL < ALL (SELECT SAL FROM EMP WHERE DEPTNO = 30);

-- 30번 부서의 최대 급여보다 더 많은 급여를 받는 사원 조회
SELECT *
FROM EMP
WHERE SAL > ALL (SELECT SAL FROM EMP WHERE DEPTNO = 30);

-- 서브쿼리 결과가 하나 이상 나오면 TRUE 반환
SELECT *
FROM EMP
WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO = 30);

-- 다중열 서브쿼리
SELECT *
FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);

-- FROM 절 서브쿼리 (= 인라인 뷰)
SELECT E10.*, D.*
FROM (SELECT * FROM EMP WHERE DEPTNO = 10) E10, (SELECT * FROM DEPT) D
WHERE E10.DEPTNO = D.DEPTNO;

-- SELECT 절 서브쿼리 (= 스칼라 서브쿼리)
SELECT 
	E.EMPNO, 
	E.ENAME, 
	E.JOB,
	(SELECT GRADE FROM SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL) AS SALGRADE, 
	DEPTNO,
	(SELECT DNAME FROM DEPT D WHERE E.DEPTNO = D.DEPTNO) AS DNAME
FROM EMP E;

-- 전체 사원 중 ALLEN과 같은 직책인 사원들의 사원정보, 부서정보 조회
-- 정보 : 사번, 이름, 직무, 급여, 부서번호, 부서명
SELECT 
	E.EMPNO, 
	E.ENAME, 
	E.JOB, 
	E.SAL, 
	E.DEPTNO, 
	(SELECT D.DNAME FROM DEPT D WHERE D.DEPTNO = E.DEPTNO) AS DNAME
FROM EMP E
WHERE E.JOB = (SELECT JOB FROM EMP WHERE ENAME = 'ALLEN');

-- 자신의 부서 내에서 최고 연봉과 동일한 급여를 받는 사원 조회
SELECT *
FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);

-- 10번 부서에 근무하는 사원 중 30번 부서에 없는 직책인 사원의 사번, 이름, 직무, 부서번호, 부서명, 부서위치 조회
SELECT E.EMPNO, E.ENAME, E.JOB, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E
JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE E.DEPTNO = 10 AND E.JOB NOT IN (SELECT JOB FROM EMP WHERE DEPTNO = 30);



-- INSERT : 테이블에 데이터 추가
-- INSERT INTO 테이블명(열이름1, 열이름2, ...) VALUES(값1, 값2, 값3, ...)
-- 열 이름 생략 가능한데 단, 모든 열의 값이 지정되어야 함

-- 연습용 테이블 생성
CREATE TABLE DEPT_TEMP
AS SELECT * FROM DEPT; -- 테이블 구조 + 데이터 복사

CREATE TABLE EMP_TEMP
AS SELECT * FROM EMP WHERE 1 <> 1; -- 테이블 구조만 복사

SELECT *
FROM DEPT_TEMP;

-- 50, DATABASE, SEOUL 삽입
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC)
VALUES (50, 'DATABASE', 'SEOUL');

-- 60, NETWORK, BUSAN
INSERT INTO DEPT_TEMP
VALUES (60, 'NETWORK', 'BUSAN');

-- 값으로 NULL 명시적으로 삽입이 가능
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC) 
VALUES (70, 'WEB', NULL);

INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC) 
VALUES (80, 'MOBILE', '');

INSERT INTO DEPT_TEMP(DEPTNO, DNAME) 
VALUES (90, 'OS');

INSERT INTO DEPT_TEMP(DNAME, LOC, DEPTNO) 
VALUES ('CLOUD', 'INCHEON', 91);

SELECT *
FROM EMP_TEMP;

INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (1111, '안유진', 'MANAGER', 9999, '2010-10-25', 4000, NULL, 20);

INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (2222, '이은지', 'PRESIDENT', NULL, '2000-01-25', 8000, 1000, 20);

INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (3333, '미미', 'MANAGER', 9999, '2015-12-25', 4000, NULL, 30);

INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (4444, '이영지', 'MANAGER', 9999, SYSDATE, 4000, NULL, 30);

-- EMP 테이블에서 SALGRADE가 1인 사원만 EMP_TEMP 삽입
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
SELECT
	E.EMPNO,
	E.ENAME,
	E.JOB,
	E.MGR,
	E.HIREDATE,
	E.SAL,
	E.COMM,
	E.DEPTNO
FROM EMP E
JOIN SALGRADE S
ON E.SAL BETWEEN S.LOSAL AND S.HISAL
AND S.GRADE = 1;

-- UPDATE
-- UPDATE 테이블명
-- SET 열이름 = 수정할값, 열이름2 = 수정할값
-- WHERE 수정할 조건
SELECT *
FROM DEPT_TEMP;

-- 10번 부서의 위치 SEOUL 변경
UPDATE DEPT_TEMP
SET LOC = 'SEOUL'
WHERE DEPTNO = 10;

-- EMP_TEMP 테이블의 사원 중에서 SAL이 2500 이하인 사원만 추가수당을 50으로 수정
UPDATE EMP_TEMP
SET COMM = 50
WHERE SAL <= 2500;

-- DEPT 테이블의 40번 부서의 DNAME, LOC 정보를 가져와서 DEPT_TEMP 40번 부서의 내용으로 변경
UPDATE DEPT_TEMP
SET (DNAME, LOC) = (SELECT DNAME, LOC FROM DEPT WHERE DEPTNO = 40)
WHERE DEPTNO = 40;

-- 전체 내용 변경
-- WHERE 조건 없이 실행
UPDATE DEPT_TEMP
SET LOC = 'BUSAN';

-- DELETE : 데이터 삭제
-- DELETE FROM 테이블명 WHERE 삭제할조건
-- DELETE 테이블명 WHERE 삭제할조건

CREATE TABLE EMP_TEMP2
AS SELECT * FROM EMP;

SELECT *
FROM EMP_TEMP2;

-- 사번이 7902인 사원 삭제
DELETE FROM EMP_TEMP2
WHERE EMPNO = 7902;

DELETE EMP_TEMP2
WHERE EMPNO = 7844;

-- 테이블 데이터 전체 삭제
DELETE FROM EMP_TEMP2;

-- EMP 테이블을 복사하여 EXAM_EMP 테이블 생성
CREATE TABLE EXAM_EMP
AS SELECT * FROM EMP;

-- DEPT 테이블을 복사하여 EXAM_DEPT 테이블 생성
CREATE TABLE EXAM_DEPT
AS SELECT * FROM DEPT;

-- SALGRADE 테이블을 복사하여 EXAM_SALGRADE 테이블 생성
CREATE TABLE EXAM_SALGRADE
AS SELECT * FROM SALGRADE;

-- EXAM_DEPT 테이블에 50, 60, 70, 80번 부서를 등록하는 SQL 구문 작성
-- 50, ORACLE, BUSAN
-- 60, SQL, ILSAN
-- 70, SELECT, INCHEON
-- 80, DML, BUNDANG
INSERT INTO EXAM_DEPT
VALUES (50, 'ORACLE', 'BUSAN');

INSERT INTO EXAM_DEPT
VALUES (60, 'SQL', 'ILSAN');

INSERT INTO EXAM_DEPT
VALUES (70, 'SELECT', 'INCHEON');

INSERT INTO EXAM_DEPT
VALUES (80, 'DML', 'BUNDANG');

-- EXAM_EMP 테이블에 8명의 사원정보를 등록하는 SQL 구문 작성
-- 8명은 임의의 값(부서번호는 50 ~ 80번 사이로 지정)
INSERT INTO EXAM_EMP
VALUES ((SELECT MAX(EMPNO) + 1 FROM EXAM_EMP), 'SUZY', 'MANAGER', 7777, SYSDATE, 1000, 100, 50);

INSERT INTO EXAM_EMP
VALUES ((SELECT MAX(EMPNO) + 1 FROM EXAM_EMP), 'WONBIN', 'MANAGER', 7777, SYSDATE, 2000, 200, 50);

INSERT INTO EXAM_EMP
VALUES ((SELECT MAX(EMPNO) + 1 FROM EXAM_EMP), 'JAESEOK', 'SALESMAN', 7777, SYSDATE, 3000, 300, 60);

INSERT INTO EXAM_EMP
VALUES ((SELECT MAX(EMPNO) + 1 FROM EXAM_EMP), 'SEHO', 'MANAGER', 7777, SYSDATE, 4000, 400, 60);

INSERT INTO EXAM_EMP
VALUES ((SELECT MAX(EMPNO) + 1 FROM EXAM_EMP), 'SOMIN', 'MANAGER', 7777, SYSDATE, 5000, 500, 60);

INSERT INTO EXAM_EMP
VALUES ((SELECT MAX(EMPNO) + 1 FROM EXAM_EMP), 'JIHYO', 'MANAGER', 7777, SYSDATE, 6000, 600, 70);

INSERT INTO EXAM_EMP
VALUES ((SELECT MAX(EMPNO) + 1 FROM EXAM_EMP), 'MIYEON', 'MANAGER', 7777, SYSDATE, 7000, 700, 70);

INSERT INTO EXAM_EMP
VALUES ((SELECT MAX(EMPNO) + 1 FROM EXAM_EMP), 'HODONG', 'SALESMAN', 7777, SYSDATE, 8000, 800, 80);

-- EXAM_EMP에서 50번 부서에 근무하는 사원의 평균 급여보다 많이 받는 사원을 70번 부서로 옮기는 SQL 구문 작성
UPDATE EXAM_EMP
SET DEPTNO = 70
WHERE SAL > (
	SELECT AVG(SAL)
	FROM EXAM_EMP
	WHERE DEPTNO = 50
);

-- EXAM_EMP에 속한 사원 중 입사일이 가장 빠른 60번 부서 사원보다 늦게 입사한 사원의 급여를 10% 인상하고
-- 80번 부서로 옮기는 SQL 구문 작성
UPDATE EXAM_EMP
SET SAL = SAL * 1.1, DEPTNO = 80
WHERE HIREDATE > (
		SELECT MIN(HIREDATE)
		FROM EXAM_EMP
		WHERE DEPTNO = 60
);

-- EXAM_EMP에 속한 사원 중 급여 등급이 5인 사원을 삭제하는 SQL 구문 작성
DELETE FROM EXAM_EMP
WHERE EMPNO IN (
	SELECT A.EMPNO
	FROM EXAM_EMP A, EXAM_SALGRADE B
	WHERE A.SAL BETWEEN B.LOSAL AND B.HISAL
	AND B.GRADE = 5
);

-- DML : INSERT, UPDATE, DELETE → 데이터 변경이 일어나는 작업
-- 트랜잭션 : 하나의 단위로 데이터 처리
-- ROLLBACK : 되돌리기
-- COMMIT : 데이터베이스 반영
CREATE TABLE DEPT_TCL 
AS SELECT * FROM DEPT;

-- ※ 트랜잭션 시작
INSERT INTO DEPT_TCL
VALUES(50, 'DATABASE', 'SEOUL');

UPDATE DEPT_TCL
SET LOC = 'BUSAN'
WHERE DEPTNO = 40;

DELETE FROM DEPT_TCL
WHERE DNAME = 'RESEARCH';
-- ※ 트랜잭션 종료

SELECT *
FROM DEPT_TCL;

ROLLBACK;

COMMIT;

-- SESSION : 데이터베이스 접속을 시작으로 작업을 수행한 후 접속을 종료하기까지 전체 기간
DELETE FROM DEPT_TCL
WHERE DEPTNO = 50;

COMMIT;

-- 다른 세션에서 수정 중인 데이터 접근은 막음
UPDATE DEPT_TCL 
SET LOC = 'SEOUL' 
WHERE DEPTNO = 30;

COMMIT;

-- 데이터 정의어(DDL)
-- 객체를 생성(CREATE), 변경(ALTER), 삭제(DROP)하는 명령어
-- 1. 테이블 생성
-- 1) 기존 테이블 이용하여 테이블 생성
-- 1-1) CREATE TABLE DEPT_TCL AS SELECT * FROM DEPT;
-- 1-2) CREATE TABLE DEPT_TCL AS SELECT * FROM DEPT WHERE 1 <> 1;
-- 1-3) CREATE TABLE 테이블명(
-- 	 	    열이름1 타입(10),
--	        열이름2 타입(20)
--      );

-- 타입(TYPE)
-- 문자 : CHAR / NCHAR / VARCHAR2 / NVARCHAR2
-- 		 CHAR (고정크기) / VARCHAR (가변크기)
--       CHAR(10) : ABC => 10자리를 그대로 사용 (한 자리 당 1BYTE)
-- 		 VARCHAR(10) : ABC => 3자리를 사용 (한 자리 당 1BYTE)
-- 		 NCHAR / NVARCHAR2 : 한 자리 당 한 글자
-- 숫자 : NUMBER(7, 2) => 소수 둘째 자리를 포함해서 총 7자리 숫자 지정 가능
-- 날짜 : DATE

-- 테이블명, 열명 : 문자로 시작, 특수문자(_, $, #) 가능, 숫자 가능
-- ※단, 예약어(SELECT, ORDER, FROM)는 사용 안됨

-- 2. 자료형을 정의하여 새 테이블 생성
CREATE TABLE EMP_DDL(
	EMPNO NUMBER(4),
	ENAME VARCHAR2(10),
	JOB VARCHAR2(9),
	MGR VARCHAR2(4),
	HIERDATE DATE,
	SAL NUMBER(7, 2),
	COMM NUMBER(7, 2),
	DEPTNO NUMBER(2)
);

-- 테이블 변경(ALTER)
-- 1. 컬럼 추가 : ADD
-- 2. 컬럼 이름 변경 : RENAME COLUMN
-- 3. 컬럼 자료형 변경 : MODIFY
-- 3. 열 삭제 : DROP COLUMN

-- HP 열 추가
ALTER TABLE EMP_DDL ADD HP VARCHAR(20);

-- HP => TEL 이름 변경
ALTER TABLE EMP_DDL RENAME COLUMN HP TO TEL;

-- EMPNO NUMBER(4) => NUMBER(5) 변경
ALTER TABLE EMP_DDL MODIFY EMPNO NUMBER(5);

-- TEL 컬럼 제거
ALTER TABLE EMP_DDL DROP COLUMN TEL;

-- 테이블 이름 변경 : RENAME 변경전 테이블명 TO 변경후 테이블명
RENAME EMP_DDL TO EMP_RENAME;

-- 테이블 삭제
-- DROP
DROP TABLE EMP_RENAME;

SELECT *
FROM EMP_DDL;

SELECT *
FROM EMP_RENAME;

-- MEMBER 테이블 생성
-- ID VARCHAR2(15)
-- PASSWORD VARCHAR2(20)
-- NAME VARCHAR2(10)
-- TEL VARCHAR2(15)
-- EMAIL VARCHAR2(20)
-- AGE NUMBER(4)
CREATE TABLE MEMBER(
	ID VARCHAR2(15),
	PASSWORD VARCHAR2(20),
	NAME VARCHAR2(10),
	TEL VARCHAR2(15),
 	EMAIL VARCHAR2(20),
 	AGE NUMBER(4)
);

-- BIGO 열 추가 => VARCHAR2(10)
ALTER TABLE MEMBER ADD BIGO VARCHAR2(10);

-- BIGO 열 크기 변경 30
ALTER TABLE MEMBER MODIFY BIGO VARCHAR2(30);

-- BIGO 열 이름을 REMARK로 변경
ALTER TABLE MEMBER RENAME COLUMN BIGO TO REMARK;

SELECT *
FROM MEMBER;

-- INDEX : 테이블 검색 성능 향상
-- INDEX 사용 여부
-- 1) TABLE FULL SCAN : 처음부터 끝까지 검색
-- 2) INDEX SCAN : INDEX를 사용한 검색
SELECT *
FROM EMP
WHERE EMPNO = 7844;

-- INDEX 생성
-- CREATE INDEX 인덱스명 ON 테이블명(컬럼명)
CREATE INDEX IDX_EMP_SAL ON EMP(SAL);

-- INDEX 삭제
-- DROP INDEX 인덱스명
DROP INDEX IDX_EMP_SAL;

-- VIEW : 가상 테이블
-- 하나 이상의 테이블을 조회하는 SELECT문을 저장한 객체
-- 사용 이유
-- 1. 보안성 (VIEW에만 접근 권한을 주고, 원본 테이블에는 접근 못하게 설정)
-- 2. 편리성 (SQL 구문의 복잡도 완화)
-- CREATE VIEW 뷰이름(열이름1, 열이름2, ...) AS (저장할 SELECT문) WITH CHECK OPTION WITH READ ONLY 제약조건
-- DROP VIEW 뷰이름
CREATE VIEW VW_EMP20 AS (SELECT EMPNO, ENAME, JOB, DEPTNO FROM EMP WHERE DEPTNO = 20);
CREATE VIEW VW_EMP_READ AS (SELECT EMPNO, ENAME, JOB, DEPTNO FROM EMP) WITH READ ONLY;

-- VIEW에 데이터 삽입
-- VIEW에는 INSERT 내용 반영 X, 원본 테이블에 INSERT 내용 반영
INSERT INTO VW_EMP20 
VALUES(7777, '태연', 'SALESMAN', 10);

-- ORA-42399: 읽기 전용 뷰에서는 DML 작업을 수행할 수 없습니다.
INSERT INTO VW_EMP_READ
VALUES(7777, '태연', 'SALESMAN', 10);

DROP VIEW VW_EMP20;
DROP VIEW VW_EMP_READ;

SELECT *
FROM VW_EMP20;

SELECT *
FROM EMP;

-- USER_ 로 시작하는 테이블 : 현재 데이터베이스에 접속한 사용자가 소유한 객체 정보
SELECT TABLE_NAME 
FROM USER_TABLES;

SELECT *
FROM USER_UPDATABLE_COLUMNS 
WHERE TABLE_NAME = 'VM_EMP20';

-- SEQUENCE (MySQL limit)
-- ORACLE 데이터베이스에서 특정 규칙에 따른 연속 숫자를 생성하는 객체
-- 기본 사용법 : CREATE SEQUENCE 시퀀스명;
-- 옵션 추가 사용법
-- CREATE SEQUENCE 시퀀스명
-- INCREMENT BY N
-- START WITH 0
-- MAXVALUE N | NOMAXVALUE
-- MINVALUE N | NOMINVALUE
-- CYCLE | NOCYCLE
-- CACHE N | NOCACHE
CREATE SEQUENCE SEQ_DEPT_SEQUENCE;

CREATE SEQUENCE SEQ_DEPT_SEQUENCE
INCREMENT BY 10
START WITH 10
MAXVALUE 90
MINVALUE 0
NOCYCLE
CACHE 2;

DROP SEQUENCE SEQ_DEPT_SEQUENCE;

-- SEQUENCE 수정
ALTER SEQUENCE SEQ_DEPT_SEQUENCE
INCREMENT BY 3
MAXVALUE 99
CYCLE;

CREATE TABLE DEPT_SEQUENCE AS SELECT * FROM DEPT WHERE 1 <> 1;

-- SEQ_DEPT_SEQUENCE.CURRVAL : 현재 시퀀스 값 조회
-- SEQ_DEPT_SEQUENCE.NEXTVAL : 다음 시퀀스 값 조회
INSERT INTO DEPT_SEQUENCE
VALUES(SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATABASE', 'SEOUL');

-- NOCYCLE 시 MAXVALUE 초과했을 경우
-- ORA-08004: 시퀀스 SEQ_DEPT_SEQUENCE.NEXTVAL exceeds MAXVALUE은 사례로 될 수 없습니다
INSERT INTO DEPT_SEQUENCE
VALUES(SEQ_DEPT_SEQUENCE.NEXTVAL, 'NETWORK', 'BUSAN');

DELETE FROM DEPT_SEQUENCE;

SELECT *
FROM DEPT_SEQUENCE
ORDER BY DEPTNO;

-- SYNONYM : 동의어(별칭)
CREATE SYNONYM E FOR EMP;

SELECT *
FROM E;

DROP SYNONYM E;



-- 제약 조건 (데이터 무결성을 위해)
-- 1. 빈 값을 허용하지 않는 NOT NULL
-- 2. 중복값을 허용하지 않는 UNIQUE
-- 3. 유일하게 하나만 존재하는 PRIMARY KEY
-- 4. 다른 테이블과 관계를 맺는 FOREIGN KEY
-- 5. 설정한 조건식을 만족하는 데이터 확인하는 CHECK
-- 6. 기본값을 지정하는 DEFAULT

-- 1) NOT NULL
CREATE TABLE TABLE_NOTNULL(
	LOGIN_ID VARCHAR2(20) NOT NULL,
	LOGIN_PWD VARCHAR2(20) NOT NULL,
	TEL VARCHAR2(20)
);

INSERT INTO TABLE_NOTNULL
VALUES ('TEST01', 'TEST01', '010-1234-5678');

-- NOT NULL 컬럼에 NULL 값 INSERT 및 UPDATE
INSERT INTO TABLE_NOTNULL
VALUES ('TEST01', NULL, '010-1234-5678');

UPDATE TABLE_NOTNULL
SET LOGIN_ID = NULL
WHERE TEL = '010-1234-5678';
-----------------------------------------

DELETE FROM TABLE_NOTNULL
WHERE LOGIN_ID = 'TEST01';

DROP TABLE TABLE_NOTNULL;

-- 제약 조건 이름 지정
CREATE TABLE TABLE_NOTNULL(
	LOGIN_ID VARCHAR2(20) CONSTRAINT TBLNN_LGNID_NN NOT NULL,
	LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLNN_LGNPWD_NN NOT NULL,
	TEL VARCHAR2(20)
);

-- TEL 제약 조건 추가
ALTER TABLE TABLE_NOTNULL MODIFY(TEL NOT NULL);
ALTER TABLE TABLE_NOTNULL MODIFY(TEL CONSTRAINT TBLNN_TEL_NN NOT NULL);

-- 제약 조건 이름 변경
ALTER TABLE TABLE_NOTNULL RENAME CONSTRAINT SYS_C0018234 TO TBLNN_TEL_NN;

-- 제약 조건 삭제
ALTER TABLE TABLE_NOTNULL DROP CONSTRAINT TBLNN_TEL_NN;

----------------------------------------------------------------
-- 2) UNIQUE
CREATE TABLE TABLE_UNIQUE(
	LOGIN_ID VARCHAR2(20) UNIQUE,
	LOGIN_PWD VARCHAR2(20) NOT NULL,
	TEL VARCHAR2(20)
);

INSERT INTO TABLE_UNIQUE
VALUES('TEST01', 'TEST01', '010-1234-5678');

-- ORA-00001: 무결성 제약 조건(SCOTT.SYS_C0018236)에 위배됩니다
INSERT INTO TABLE_UNIQUE
VALUES('TEST01', 'TEST02', '010-1234-5678');

-- UNIQUE는 NULL값을 중복하여 INSERT 하여도 중복으로 판단하지 않음
INSERT INTO TABLE_UNIQUE
VALUES(NULL, 'TEST02', '010-1234-5678');

UPDATE TABLE_UNIQUE
SET LOGIN_ID = 'TEST01';

DROP TABLE TABLE_UNIQUE;

-- UNIQUE 제약 조건 이름 지정
CREATE TABLE TABLE_UNIQUE(
	LOGIN_ID VARCHAR2(20) CONSTRAINT TBL_LGNID_UNQ UNIQUE,
	LOGIN_PWD VARCHAR2(20) NOT NULL,
	TEL VARCHAR2(20)
);

-- TEL UNIQUE 제약 조건 추가
ALTER TABLE TABLE_UNIQUE MODIFY(TEL CONSTRAINT TBL_TEL_UNQ UNIQUE);

---------------------------------------------------------------------
-- 3) PRIMARY KEY(기본키)
-- UNIQUE + NOT NULL
CREATE TABLE TABLE_PK(
	LOGIN_ID VARCHAR2(20) PRIMARY KEY,
	LOGIN_PWD VARCHAR2(20) NOT NULL,
	TEL VARCHAR2(20) NOT NULL UNIQUE
);

INSERT INTO TABLE_PK 
VALUES('TEST02', 'TEST01', '010-1234-5678');

INSERT INTO TABLE_PK 
VALUES(NULL, 'TEST01', '010-1234-5678');

DROP TABLE TABLE_PK;

-----------------------------------------------
-- 4) FOREIGN KEY(외래키)
CREATE TABLE DEPT_FK(
	DEPTNO NUMBER(2) PRIMARY KEY,
	DNAME VARCHAR2(14),
	LOC VARCHAR2(13)
);

CREATE TABLE EMP_FK(
	EMPNO NUMBER(4),
	ENAME VARCHAR2(10),
	JOB VARCHAR2(9),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7, 2),
	COMM NUMBER(7, 2),
	DEPTNO NUMBER(2) REFERENCES DEPT_FK(DEPTNO)
);

-- ORA-02291: 무결성 제약조건(SCOTT.SYS_C0018252)이 위배되었습니다- 부모 키가 없습니다
INSERT INTO EMP_FK
VALUES(7201, 'TEST_USER1', 'MANAGER', 7788, '2016-01-02', 4500, NULL, 50);

-- 입력 시 부모 테이블 데이터 먼저 입력 후 자식 테이블 데이터 입력
INSERT INTO DEPT_FK
VALUES(10, 'DATABASE', 'SEOUL');

INSERT INTO EMP_FK
VALUES(7201, 'TEST_USER1', 'MANAGER', 7788, '2016-01-02', 4500, NULL, 10);

-- UPDATE
-- ORA-02291: 무결성 제약조건(SCOTT.SYS_C0018252)이 위배되었습니다- 부모 키가 없습니다
UPDATE EMP_FK
SET DEPTNO = 20
WHERE EMPNO = 7201;

-- DELETE
-- 자식 레코드 존재시 부모 삭제 불가
-- 1) 자식 레코드 먼저 삭제
-- 2) 부모 레코드 삭제
-- ORA-02292: 무결성 제약조건(SCOTT.SYS_C0018252)이 위배되었습니다- 자식 레코드가 발견되었습니다
DELETE FROM DEPT_FK
WHERE DEPTNO = 10; -- 부모

DELETE FROM EMP_FK
WHERE EMPNO = 7201; -- 자식

-- ORA-02449: 외래 키에 의해 참조되는 고유/기본 키가 테이블에 있습니다
-- 참조 테이블을 먼저 삭제 후 부모 테이블 삭제
DROP TABLE DEPT_FK;
DROP TABLE EMP_FK;

-- 제약 조건명 + 부모 데이터 삭제 시 자식 데이터 처리 방법 지정
-- ON DELETE CASCADE : 부모 데이터 삭제 시 참조하는 데이터도 함께 삭제
-- ON DELETE SET NULL : 부모 데이터 삭제 시 참조하는 데이터에 NULL로 설정
CREATE TABLE DEPT_FK(
	DEPTNO NUMBER(2) CONSTRAINT DEPTFK_DEPTNO_PK PRIMARY KEY,
	DNAME VARCHAR2(14),
	LOC VARCHAR2(13)
);

CREATE TABLE EMP_FK(
	EMPNO NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY,
	ENAME VARCHAR2(10),
	JOB VARCHAR2(9),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7, 2),
	COMM NUMBER(7, 2),
	DEPTNO NUMBER(2) CONSTRAINT EMPFK_DEPTNO_FK REFERENCES DEPT_FK(DEPTNO) ON DELETE SET NULL
);

INSERT INTO DEPT_FK
VALUES(10, 'DATABASE', 'SEOUL');

INSERT INTO EMP_FK
VALUES(7201, 'TEST_USER1', 'MANAGER', 7788, '2016-01-02', 4500, NULL, 10);

DELETE FROM DEPT_FK
WHERE DEPTNO = 10;

SELECT *
FROM DEPT_FK;

SELECT *
FROM EMP_FK;

-- 외래키 제약조건 따로 지정하는 방법
CREATE TABLE DEPT_FK(
	DEPTNO NUMBER(2) PRIMARY KEY,
	DNAME VARCHAR2(14),
	LOC VARCHAR2(13)
);

CREATE TABLE EMP_FK(
	EMPNO NUMBER(4) PRIMARY KEY,
	ENAME VARCHAR2(10),
	JOB VARCHAR2(9),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7, 2),
	COMM NUMBER(7, 2),
	DEPTNO NUMBER(2)
);

ALTER TABLE EMP_FK ADD FOREIGN KEY (DEPTNO) REFERENCES DEPT_FK(DEPTNO);

------------------------------------------------------------------------
-- 5) CHECK
CREATE TABLE TABLE_CHECK(
	LOGIN_ID VARCHAR2(20) NOT NULL,
	LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLCK_LOGINPW_CK CHECK (LENGTH(LOGIN_PWD) > 3),
	TEL VARCHAR2(20)
);

-- ORA-02290: 체크 제약조건(SCOTT.TBLCK_LOGINPW_CK)이 위배되었습니다
INSERT INTO TABLE_CHECK
VALUES('TEST01', '123', '010-1234-5678');

DROP TABLE TABLE_CHECK;

CREATE TABLE TABLE_CHECK(
	LOGIN_ID VARCHAR2(20) NOT NULL,
	LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLCK_LOGINPW_CK CHECK (LENGTH(LOGIN_PWD) > 3),
	AGE NUMBER(3) CONSTRAINT TBLCK_AGE_CK CHECK (AGE BETWEEN 10 AND 18),
	TEL VARCHAR2(20)
);

INSERT INTO TABLE_CHECK
VALUES('TEST01', '1234', 12, '010-1234-5678');

SELECT *
FROM TABLE_CHECK;

----------------------------------------------------------
-- 6) DEFAULT
CREATE TABLE TABLE_DEFAULT(
	LOGIN_ID VARCHAR2(20) NOT NULL,
	LOGIN_PWD VARCHAR2(20) DEFAULT '1234',
	TEL VARCHAR2(20)
);

INSERT INTO TABLE_DEFAULT(LOGIN_ID, TEL) 
VALUES('TEST01', '010-1234-5678');

INSERT INTO TABLE_DEFAULT
VALUES('TEST02', NULL, '010-9876-5432');

SELECT *
FROM TABLE_DEFAULT;

DROP TABLE TABLE_DEFAULT;